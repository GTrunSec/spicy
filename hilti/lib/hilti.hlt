
module hilti {

public type BitOrder = enum { LSB0, MSB0 } &cxxname="hilti::rt::integer::BitOrder";
public type ByteOrder = enum { Little, Big, Network, Host } &cxxname="hilti::rt::ByteOrder";
public type Side = enum { Left, Right, Both } &cxxname="hilti::rt::bytes::Side";
public type AddressFamily = enum { IPv4, IPv6 } &cxxname="hilti::rt::AddressFamily";
public type RealType = enum { IEEE754_Single, IEEE754_Double } &cxxname="hilti::rt::real::Type";
public type Protocol = enum { TCP, UDP, ICMP } &cxxname="hilti::rt::Protocol";
public type Charset = enum { ASCII, UTF8} &cxxname="hilti::rt::bytes::Charset";

public type MatchState = __library_type("hilti::rt::regexp::MatchState");

declare public void print(any obj, bool newline = True) &cxxname="hilti::rt::print";
declare public void printValues(tuple<*> t, bool newline = True) &cxxname="hilti::rt::printValues";

declare public void debug(string dbg_stream, any obj) &cxxname="HILTI_RT_DEBUG";
declare public void debugIndent(string dbg_stream) &cxxname="hilti::rt::debug::indent";
declare public void debugDedent(string dbg_stream) &cxxname="hilti::rt::debug::dedent";

declare public time current_time() &cxxname="hilti::rt::time::current_time";

declare public void abort() &cxxname="hilti::rt::abort_with_backtrace";

# Base type for all exceptions.
public type Exception = exception &cxxname="hilti::rt::Exception";

# Base type for all exception generated by the runtime system. Catching
# this allows to continue after operations triggering runtime errors.
public type RuntimeError = exception &cxxname="hilti::rt::RuntimeError";

}
