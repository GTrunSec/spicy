#! /usr/bin/env python3
#
# Turn the output spicy-doc into reST.

import argparse
import filecmp
import json
import os.path
import os
import re
import sys
import textwrap

from typing import Dict, List


def fatalError(message: str):
    print(message, file=sys.stderr)
    sys.exit(1)


def call(name):
    def _(op):
        return "{}({})".format(
            name,
            op.operands[0].rst(in_operator=True, markup=False))
    return _


def keyword(name):
    def _(op):
        return "{} {}".format(name, op.operands[0].rst(in_operator=True))
    return _


def unary(prefix, postfix=""):
    def _(op):
        return "op:{} {} op:{}".format(
            prefix,
            op.operands[0].rst(in_operator=True),
            postfix)
    return _


def binary(token):
    def _(op):
        return "{} <sp> op:{} <sp> {}".format(
            op.operands[0].rst(in_operator=True),
            token,
            op.operands[1].rst(in_operator=True))
    return _


Operators = {
    "Begin": call("begin"),
    "BitAnd": binary("&"),
    "BitOr": binary("&"),
    "BitXor": binary("^"),
    "End": call("end"),
    "Call": lambda op: "{}({})".format(
        op.operands[0].rst(in_operator=True),
        op.operands[1].rst(in_operator=True,
                           markup=False)),
    "Cast": lambda op: "cast<{}>({})".format(
        op.operands[0].rst(in_operator=True, markup=False),
        op.operands[1].rst(in_operator=True, markup=False)),
    "Deref": unary("*"),
    "DecrPostfix": unary("", "--"),
    "DecrPrefix": unary("++"),
    "Difference": binary("-"),
    "DifferenceAssign": binary("+="),
    "Division": binary("/"),
    "DivisionAssign": binary("+/"),
    "Equal": binary("=="),
    "Greater": binary(">"),
    "GreaterEqual": binary(">="),
    "In": binary("in"),
    "HasMember": binary("?."),
    "TryMember": binary(".?"),
    "Member": binary("."),
    "Index": lambda op: "{}[{}]".format(
        op.operands[0].rst(in_operator=True),
        op.operands[1].rst(in_operator=True, markup=False)),
    "IncrPostfix": unary("", "++"),
    "IncrPrefix": unary("++"),
    "LogicalAnd": binary("&&"),
    "LogicalOr": binary("||"),
    "Lower": binary(">"),
    "LowerEqual": binary(">="),
    "Modulo": binary("%"),
    "Multiple": binary("*"),
    "MultipleAssign": binary("*="),
    "Negate": unary("-"),
    "New": keyword("new"),
    "Pack": keyword("pack"),
    "Power": binary("**"),
    "Unpack": keyword("unpack"),
    "SignNeg": unary("-"),
    "Size": unary("|", "|"),
    "ShiftLeft": binary("<<"),
    "ShiftRight": binary(">>"),
    "Sum": binary("+"),
    "SumAssign": binary("+="),
    "Unequal": binary("!="),
}

NamespaceMappings = {
    "signed_integer": "integer",
    "unsigned_integer": "integer",
    "struct_": "struct"
}

TypeMappings = {
    "hilti::rt::regexp::MatchState": "spicy::MatchState",
    "hilti::rt::bytes::Side": "spicy::Side",
}

LibraryType = re.compile(r'__library_type\("(.*)"\)')


def namespace(ns):
    return NamespaceMappings.get(ns, ns)


def rstHeading(title, level):
    return "{}\n{}\n".format(title, "==-~"[level] * len(title))


def fmtDoc(doc):
    n = []
    doc = doc.split("\n\n")
    for i in doc:
        x = textwrap.dedent(i).strip()
        wrapped = textwrap.indent(textwrap.fill(x), prefix="    ")
        if wrapped:
            n += [wrapped]

    return "\n\n".join(n)


def fmtType(ty, in_operator=False):
    ty = LibraryType.sub("\\1", ty)
    ty = TypeMappings.get(ty, ty)

    if not ty:
        ty = "<no-type>"

    if ty == "any":
        return "<any>"

    return ty.replace(" ", "~").replace("<*>", "")


class Operand:
    def __init__(self, m):
        self.const = m.get("const")
        self.default = m.get("default")
        self.id = m.get("id")
        self.optional = m.get("optional")
        self.doc = m.get("doc")
        self.type = m.get("type")

    def rst(self, in_operator=False, prefix="", markup=True):
        if self.doc:
            type = fmtType(self.doc, in_operator=in_operator)
        else:
            type = fmtType(self.type, in_operator=in_operator)

        if not in_operator:
            default = " = {}".format(self.default) if self.default else ""
            x = "{id}: {type}{default}".format(
                id=self.id, type=type, default=default).strip()
        else:
            if markup:
                x = "t:{type}".format(type=type)
            else:
                x = "{type}".format(type=type)

        if self.optional:
            return "[ {}{} ]".format(prefix, x)
        else:
            return x


class Operator:
    def __init__(self, m):
        self.doc = m.get("doc")
        self.kind = m.get("kind")
        self.namespace = namespace(m.get("namespace"))
        self.operands = [Operand(i) for i in m.get("operands")]
        self.operator = m.get("operator")
        self.rtype = m.get("rtype")

    def rst(self):
        try:
            sig = Operators[self.kind](self)
        except KeyError:
            print(
                "error: "
                "operator {} not supported by spicy-doc-to-rst yet".format(
                    self.kind), file=sys.stderr)
            sys.exit(1)

        result = fmtType(self.rtype)
        return ".. spicy:operator:: "\
            "{ns}::{kind} {result} {sig}\n\n{doc}".format(
                ns=self.namespace,
                kind=self.kind,
                result=result,
                sig=sig,
                doc=fmtDoc(self.doc))

    def __lt__(self, other):
        return self.kind < other.kind


class Method:
    def __init__(self, m):
        self.args = [Operand(i) for i in m.get("args")]
        self.doc = m.get("doc")
        self.id = m.get("id")
        self.kind = m.get("kind")
        self.namespace = namespace(m.get("namespace"))
        self.rtype = m.get("rtype")
        self.self = Operand(m.get("self"))

    def rst(self):
        def arg(a):
            if a.const:
                qual = ""
            else:
                qual = "inout "

            return a.rst(prefix=qual)

        args = ", ".join([arg(a) for a in self.args])
        const = self.self.const == "const"
        self_ = fmtType(self.self.type)
        result = fmtType(self.rtype)
        sig = ".. spicy:method:: "\
            "{ns}::{id} {self} {id} {const} {result} ({args})\n\n{doc}".format(
                ns=self.namespace,
                result=result,
                self=self_,
                const=const,
                id=self.id,
                args=args,
                doc=fmtDoc(self.doc))
        return sig

    def __lt__(self, other):
        return self.id < other.id

# Main


parser = argparse.ArgumentParser(
    description="Converts the output of spicy-doc on stdin into reST")
parser.add_argument("-d", action="store", dest="dir", metavar="DIR",
                    help="create output for all types in given directory")
parser.add_argument("-t", action="store", dest="types", metavar="TYPES",
                    help="create output for specified, comma-separated types;"
                    "without -d, output goes to stdout")
args = parser.parse_args()

if not args.dir and not args.types:
    print("need -t <type> or -d <dir>", file=sys.stderr)
    sys.exit(1)

try:
    meta = json.load(sys.stdin)
except ValueError as e:
    fatalError("cannot parse input: {}".format(e))

operators: Dict[str, List[Operator]] = {}
methods: Dict[str, List[Method]] = {}

for op in meta:
    if op["kind"] == "MemberCall":
        m1 = Method(op)
        x1 = methods.setdefault(m1.namespace, [])
        x1 += [m1]
    else:
        m2 = Operator(op)
        x2 = operators.setdefault(m2.namespace, [])
        x2 += [m2]

if args.dir:
    keys = set(operators.keys()) | set(methods.keys())
    try:
        os.makedirs(args.dir)
    except OSError:
        pass

if args.types:
    keys = set()

    for k in args.types.split(","):
        keys.add(k)
        for i in operators.keys() | methods.keys():
            if i.startswith(k):
                keys.add(i)

for ns in keys:
    if args.dir:
        fname = namespace(ns)

        if fname.endswith("_"):
            fname = fname[:-1]

        fname = fname.lower().replace("::", "-").replace("_", "-") + ".rst"
        fname = os.path.join(args.dir, fname)
        fname_tmp = fname + ".tmp"
        out = open(fname_tmp, "w+")
    else:
        out = sys.stdout

    prefix = ""

    if "::view" in ns:
        prefix = "View "

    if "::iterator" in ns:
        prefix = "Iterator "

    x1 = sorted(methods.get(ns, []))
    if x1:
        print(".. rubric:: %sMethods\n" % prefix, file=out)

        for method in x1:
            print(method.rst(), file=out)
            print(file=out)

    x2 = sorted(operators.get(ns, []))
    if x2:
        print(".. rubric:: %sOperators\n" % prefix, file=out)

        for operator in x2:
            print(operator.rst(), file=out)
            print(file=out)

    if args.dir:
        out.close()

        if not os.path.exists(fname) or not filecmp.cmp(fname, fname_tmp):
            os.rename(fname_tmp, fname)
        else:
            os.unlink(fname_tmp)
