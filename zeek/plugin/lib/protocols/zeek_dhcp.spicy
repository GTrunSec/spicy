# Copyright (c) 2020 by the Zeek Project. See LICENSE for details.

module Zeek_DHCP;

import DHCP from protocols;
# import DHCP;
import zeek;

on DHCP::Message::%done {
    zeek::confirm_protocol();
}

on DHCP::Message::%error {
    zeek::reject_protocol("error while parsing DHCP request");
}

public function create_options(msg: DHCP::Message):
    tuple<
        options: vector<uint32>,
        subnet_mask: addr,
        routers: vector<addr>,
        dns_servers: vector<addr>,
        host_name: string,
        domain_name: string,
        forwarding: bool,
        broadcast: addr,
        vendor: string,
        nbns: vector<addr>,
        addr_request: addr,
        lease: interval,
        serv_addr: addr,
        param_list: vector<uint32>,
        message: string,
        max_msg_size: uint32,
        renewal_time: interval,
        rebinding_time: interval,
        vendor_class: string,
        client_id: tuple<
            hwtype: uint32,
            hwaddr: string>,
        user_class: string,
        client_fqdn: tuple<
            flags: uint32,
            rcode1: uint32,
            rcode2: uint32,
            domain_name: string>,
        sub_opt: vector<tuple<
            code: uint32,
            value: string>>,
        auto_config: bool,
        auto_proxy_config: string,
        time_offset: int64,
        time_servers: vector<addr>,
        name_servers: vector<addr>,
        ntp_servers: vector<addr>> {

    local options = [cast<uint32>(option.code) for option in msg.options.options];

    local add_request: vector<addr>;
    local param_list: vector<vector<uint32>>;
    local client_id: vector<tuple<uint32, string>>;
    local time_offset: vector<int32>;
    local routers: vector<addr>;
    local time_servers: vector<addr>;
    local name_servers: vector<addr>;
    local domain_name_servers: vector<addr>;
    local host_name: vector<string>;
    local domain_name: vector<string>;
    local forwarding: vector<uint8>; # TODO(bbannier): Make this a `vector<bool>` once #392 is fixed.
    local broadcast_address: vector<addr>;
    local network_time_protocol_servers: vector<addr>;
    local vendor_specific_information: vector<string>;
    local netbios_over_tcpip_name_servers: vector<addr>;
    local ip_address_lease_time: vector<interval>;
    local server_identifier: vector<addr>;
    local message: vector<string>;
    local maximum_dhcp_message_size: vector<uint32>;
    local renewal_time_value: vector<interval>;
    local rebind_time_value: vector<interval>;
    local class_identifier: vector<string>;
    local user_class: vector<string>;

    for (option in msg.options.options) {
        if (option?.requested_address)
            add_request.push_back(option.requested_address);

        if (option?.request_values) {
            local values: vector<uint32>;

            for (value in values)
                values.push_back(cast<uint32>(value));

            param_list.push_back(values);
        }

        if (option?.client_type) {
            client_id.push_back(
                (cast<uint32>(option.client_type),
                 option.client_identifier.decode(hilti::Charset::ASCII)));
        }

        if (option?.time_offset)
            time_offset.push_back(option.time_offset);

        if (option?.routers)
            for (address in option.routers)
                routers.push_back(address);

        if (option?.time_servers)
            for (address in option.time_servers)
                time_servers.push_back(address);

        if (option?.name_servers)
            for (address in option.name_servers)
                name_servers.push_back(address);

        if (option?.domain_name_servers)
            for (address in option.domain_name_servers)
                domain_name_servers.push_back(address);

        if (option?.host_name)
            host_name.push_back(option.host_name);

        if (option?.domain_name)
            domain_name.push_back(option.domain_name);

        if (option?.forwarding)
            forwarding.push_back(option.forwarding);

        if (option?.broadcast_address)
            broadcast_address.push_back(option.broadcast_address);

        if (option?.network_time_protocol_servers)
            for (address in option.network_time_protocol_servers)
                network_time_protocol_servers.push_back(address);

        if (option?.vendor_specific_information)
            vendor_specific_information.push_back(option.vendor_specific_information);

        if (option?.netbios_over_tcpip_name_servers)
            for (address in option.netbios_over_tcpip_name_servers)
                netbios_over_tcpip_name_servers.push_back(address);

        if (option?.ip_address_lease_time)
            ip_address_lease_time.push_back(cast<interval>(option.ip_address_lease_time));

        if (option?.server_identifier)
            server_identifier.push_back(option.server_identifier);

        if (option?.message)
            message.push_back(option.message);

        if (option?.maximum_dhcp_message_size)
            maximum_dhcp_message_size.push_back(cast<uint32>(option.maximum_dhcp_message_size));

        if (option?.renewal_time_value)
            renewal_time_value.push_back(cast<interval>(option.renewal_time_value));

        if (option?.rebind_time_value)
            rebind_time_value.push_back(cast<interval>(option.rebind_time_value));

        if (option?.class_identifier)
            class_identifier.push_back(option.class_identifier);

        if (option?.user_class)
            user_class.push_back(option.user_class.decode(hilti::Charset::ASCII));
    }

    return (
        options,
        0.0.0.0,            # TODO(bbannier): parse option 1.
        routers,
        domain_name_servers,
        host_name[0],
        domain_name[0],
        forwarding[0] == 1,
        broadcast_address[0],
        vendor_specific_information[0],
        netbios_over_tcpip_name_servers,
        add_request[0],
        ip_address_lease_time[0],
        server_identifier[0],
        param_list[0],
        message[0],
        maximum_dhcp_message_size[0],
        renewal_time_value[0],
        rebind_time_value[0],
        class_identifier[0],
        client_id[0],
        user_class[0],
        (0, 0, 0, ""),      # TODO(bbannier): parse option 81.
        vector(),           # TODO(bbannier): parse option 82.
        False,              # TODO(bbannier): parse option 116.
        "",                 # TODO(bbannier): parse option 252.
        time_offset[0],
        time_servers,
        name_servers,
        network_time_protocol_servers,
    );
}

public function create_msg(msg: DHCP::Message):
    tuple<
        op: uint32,
        m_type: uint32,
        xid: uint32,
        secs: interval,
        flags: uint32,
        ciaddr: addr,
        yiaddr: addr,
        siaddr: addr,
        giaddr: addr,
        chaddr: string,
        sname: string,
        file_n: string> {
    return (
        cast<uint32>(msg.op),
        cast<uint32>(msg.htype),
        msg.xid,
        cast<interval>(msg.secs),
        cast<uint32>(msg.flags),
        msg.ciaddr,
        msg.yiaddr,
        msg.siaddr,
        msg.giaddr,
        msg.chaddr.decode(hilti::Charset::ASCII),
        msg.sname,
        msg.file_n
    );
}
